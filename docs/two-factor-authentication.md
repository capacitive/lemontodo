# Two-Factor Authentication (2FA) with TOTP

A developer reference for implementing Time-based One-Time Password authentication in any application.

---

## Table of Contents

1. [Overview](#overview)
2. [How TOTP Works](#how-totp-works)
3. [Setup Flow](#setup-flow)
4. [Login Flow with 2FA](#login-flow-with-2fa)
5. [Disable Flow](#disable-flow)
6. [Security Considerations](#security-considerations)
7. [Implementation Checklist](#implementation-checklist)
8. [Recommended Libraries by Platform](#recommended-libraries-by-platform)
9. [Architecture Diagram](#architecture-diagram)
10. [Known Limitations and Future Enhancements](#known-limitations-and-future-enhancements)

---

## Overview

Two-Factor Authentication (2FA) adds a second layer of verification beyond a password. TOTP-based 2FA uses a shared secret between the server and an authenticator app on the user's device to generate short-lived, one-time codes.

**How it works at a high level:**

- During setup, the server generates a secret and shares it with the user's authenticator app (typically via QR code).
- At login, the user provides their password (first factor) and a 6-digit code from their authenticator app (second factor).
- The server independently computes the expected code using the shared secret and the current time, then compares it to what the user submitted.

**Supported authenticator apps:**

Any app that implements [RFC 6238](https://datatracker.ietf.org/doc/html/rfc6238) (TOTP) is compatible. This includes:

- Microsoft Authenticator
- Google Authenticator
- Duo Mobile
- Authy
- 1Password
- Bitwarden Authenticator
- FreeOTP
- Any other RFC 6238 compliant application

---

## How TOTP Works

TOTP generates a one-time password from two inputs: a **shared secret** and the **current time**.

### The Algorithm (Simplified)

```
TOTP = HMAC-SHA1(secret, time_step) → truncate to 6 digits
```

**Step by step:**

1. **Shared secret** -- A random value (typically 160 bits / 20 bytes) generated by the server and shared with the authenticator app during setup. The secret is encoded as a **base32 string** for transport (e.g., `JBSWY3DPEHPK3PXP`).

2. **Time step** -- The current Unix timestamp is divided by the **period** (default 30 seconds) to produce a counter value. This means the same code is valid for one 30-second window.

   ```
   time_step = floor(current_unix_time / 30)
   ```

3. **HMAC-SHA1** -- The time step (as an 8-byte big-endian integer) is signed using HMAC-SHA1 with the shared secret as the key. This produces a 20-byte hash.

4. **Dynamic truncation** -- A 4-byte segment is extracted from the hash using an offset derived from the last nibble of the hash. This 4-byte value is converted to a 31-bit unsigned integer.

5. **Modulo** -- The integer is reduced to 6 digits:

   ```
   code = truncated_value % 1_000_000
   ```

   The result is zero-padded to always produce exactly 6 digits (e.g., `007832`).

### Key Parameters

| Parameter | Default Value | Description |
|-----------|--------------|-------------|
| Algorithm | SHA-1 | HMAC hash algorithm |
| Digits | 6 | Length of the generated code |
| Period | 30 seconds | Duration of each time window |
| Secret length | 160 bits (20 bytes) | Minimum recommended by RFC 4226 |

### Why It Works

Both the server and the authenticator app have the same secret and the same clock. Given the same inputs, they independently compute the same 6-digit code. No network communication between the app and the server is needed at verification time.

---

## Setup Flow

This is the one-time process where a user enrolls their authenticator app.

### Step 1: Generate a Secret

Generate a cryptographically secure random value of at least 160 bits (20 bytes).

```csharp
// .NET example
byte[] secretBytes = RandomNumberGenerator.GetBytes(20);
```

```javascript
// Node.js example
const crypto = require('crypto');
const secretBytes = crypto.randomBytes(20);
```

### Step 2: Encode as Base32

Authenticator apps expect the secret as a base32-encoded string (RFC 4648, no padding).

```
Raw bytes:  48 65 6C 6C 6F ...
Base32:     JBSWY3DPEHPK3PXP
```

### Step 3: Build the otpauth:// URI

The `otpauth://` URI scheme is the standard way to provision TOTP credentials to authenticator apps.

```
otpauth://totp/{issuer}:{account}?secret={base32_secret}&issuer={issuer}&digits=6&period=30&algorithm=SHA1
```

**Example:**

```
otpauth://totp/MyApp:user@example.com?secret=JBSWY3DPEHPK3PXP&issuer=MyApp&digits=6&period=30&algorithm=SHA1
```

| Parameter | Value | Notes |
|-----------|-------|-------|
| `issuer` | Your application name | Displayed in the authenticator app |
| `account` | User's email or username | Identifies the account |
| `secret` | Base32-encoded secret | No padding characters |
| `digits` | `6` | Standard code length |
| `period` | `30` | Seconds per time step |
| `algorithm` | `SHA1` | Default; most apps only support SHA-1 |

### Step 4: Render a QR Code

Encode the `otpauth://` URI into a QR code and display it to the user. The frontend generates the QR code from the URI string returned by the backend.

### Step 5: User Scans the QR Code

The user opens their authenticator app, selects "Add account" or "Scan QR code," and scans the displayed QR code. The app extracts the secret and begins generating codes.

### Step 6: User Enters a Verification Code

To confirm the setup was successful, the user enters the current 6-digit code displayed in their authenticator app.

### Step 7: Backend Validates and Stores

The backend:

1. Computes the expected TOTP code using the generated secret and current time.
2. Compares it to the code the user submitted (with a tolerance window of +/- 1 time step).
3. If valid:
   - Encrypts the secret (AES-256-GCM recommended) and stores it in the database.
   - Sets the user's `two_factor_enabled` flag to `true`.
4. If invalid:
   - Returns an error. The user can retry or rescan the QR code.

**Important:** The plaintext secret should never be returned in API responses after the initial setup. Once stored, only the encrypted form exists on the server.

---

## Login Flow with 2FA

### Step 1: User Submits Credentials

The user submits their email/username and password as usual.

### Step 2: Backend Validates the Password

The backend verifies the credentials against the stored password hash. If invalid, return a standard 401 Unauthorized response.

### Step 3: Check if 2FA Is Enabled

If the user has `two_factor_enabled = true`, **do not issue tokens yet**. Instead, return a partial response indicating that a second factor is required.

```json
{
  "requiresTwoFactor": true,
  "twoFactorToken": "temporary-session-token"
}
```

The `twoFactorToken` is a short-lived token (e.g., 5 minutes) that ties the TOTP verification step back to the authenticated user without issuing a full session or JWT.

### Step 4: Frontend Shows TOTP Input

The frontend detects `requiresTwoFactor: true` and presents a 6-digit code input field.

### Step 5: User Enters the Code

The user opens their authenticator app, reads the current code, and enters it.

### Step 6: Backend Validates the TOTP Code

The backend:

1. Decrypts the user's stored TOTP secret.
2. Computes the expected code for the current time step.
3. Also computes codes for the **previous** and **next** time steps (tolerance of +/- 1 step, covering +/- 30 seconds of clock drift).
4. Compares the submitted code against all three valid codes.

```
Valid codes at time T:
  - TOTP(secret, T - 1)   ← 30 seconds ago
  - TOTP(secret, T)       ← current
  - TOTP(secret, T + 1)   ← 30 seconds ahead
```

### Step 7: Issue Tokens or Reject

- **On success:** Issue the full authentication token (JWT, session cookie, etc.) as if the user had completed a normal login.
- **On failure:** Return 401 Unauthorized with an appropriate error message. Increment the rate limit counter.

```json
{
  "error": "Invalid verification code. Please try again."
}
```

---

## Disable Flow

Disabling 2FA must require proof that the user currently has access to their authenticator app. This prevents an attacker who has compromised the password (but not the authenticator) from stripping the second factor.

### Steps

1. User navigates to security settings and selects "Disable 2FA."
2. Frontend prompts for the current 6-digit TOTP code.
3. User enters the code from their authenticator app.
4. Backend validates the code against the stored secret (same validation as login).
5. If valid:
   - Set `two_factor_enabled = false`.
   - Delete (or nullify) the stored encrypted secret.
   - Return success.
6. If invalid:
   - Return 401/403. 2FA remains enabled.

---

## Security Considerations

### Secret Storage

- **Encrypt secrets at rest** using AES-256-GCM or an equivalent authenticated encryption scheme.
- Store the encryption key separately from the database (e.g., in a key vault, environment variable, or HSM).
- Never store the plaintext secret in the database.

### Rate Limiting

- Limit TOTP verification attempts to **5 per minute** per user.
- After exceeding the limit, temporarily lock TOTP verification for that user (e.g., 15-minute cooldown).
- This mitigates brute-force attacks. A 6-digit code has 1,000,000 possible values; without rate limiting, an attacker could exhaust the space quickly.

### Time Window Tolerance

- Accept codes from the **current time step** plus **one step before** and **one step after** (total window: approximately 90 seconds).
- This accounts for minor clock drift between the server and the user's device.
- Do not increase the tolerance beyond +/- 1 step without a strong reason.

### Code Reuse Prevention

- TOTP codes are only valid within their 30-second time window.
- Optionally, track the last successfully used time step per user to prevent replay of the same code within the same window.

### Recovery Codes

- Generate **10 one-time-use recovery codes** during 2FA setup (e.g., 8-character alphanumeric strings).
- Store them hashed (bcrypt or SHA-256) alongside the user record.
- Each code can only be used once. After use, mark it as consumed.
- Present recovery codes to the user only once, during setup, and instruct them to store the codes securely offline.
- This is a critical safety net; plan for it even if not in the initial release.

### Logging and Exposure

- Never log TOTP secrets, codes, or recovery codes.
- After the initial setup response (which includes the `otpauth://` URI), never return the secret in any subsequent API response.
- Audit log 2FA events (enabled, disabled, failed attempts) without including sensitive values.

### Random Number Generation

- Use a **cryptographically secure** random number generator for secret generation.
  - .NET: `System.Security.Cryptography.RandomNumberGenerator`
  - Node.js: `crypto.randomBytes`
  - Python: `os.urandom` or `secrets`
  - Go: `crypto/rand`
- Do not use `Math.random()`, `System.Random`, or any non-cryptographic PRNG.

---

## Implementation Checklist

### Backend

- [ ] **Secret generation** -- Generate 20-byte (160-bit) cryptographically random secrets.
- [ ] **Base32 encoding** -- Encode secrets as base32 strings (no padding) for the otpauth URI.
- [ ] **otpauth URI generation** -- Build the URI with issuer, account, secret, digits=6, period=30.
- [ ] **TOTP validation** -- Validate 6-digit codes with +/- 1 time step tolerance.
- [ ] **Encrypted storage** -- Encrypt secrets with AES-256-GCM before persisting to the database.
- [ ] **2FA setup endpoint** -- `POST /2fa/setup` returns the otpauth URI (and optionally the base32 secret as a manual entry fallback).
- [ ] **2FA enable endpoint** -- `POST /2fa/enable` accepts a verification code, validates it, and activates 2FA.
- [ ] **2FA disable endpoint** -- `POST /2fa/disable` requires a valid TOTP code to deactivate 2FA.
- [ ] **Login flow modification** -- Return `requiresTwoFactor: true` instead of tokens when 2FA is active.
- [ ] **TOTP verification endpoint** -- `POST /2fa/verify` accepts the TOTP code and temporary token, returns full auth tokens on success.
- [ ] **Rate limiting** -- Enforce 5 attempts per minute on TOTP verification endpoints.

### Frontend

- [ ] **QR code display** -- Render the otpauth URI as a QR code during setup.
- [ ] **Manual entry fallback** -- Display the base32 secret as copyable text for users who cannot scan QR codes.
- [ ] **Verification form** -- 6-digit input field with auto-submit on completion.
- [ ] **2FA toggle in settings** -- Enable/disable 2FA from the user's security settings page.
- [ ] **Login flow update** -- Detect `requiresTwoFactor` in the login response and show the TOTP input.

### Database

- [ ] **Add columns to user table:**
  - `totp_secret` -- encrypted string, nullable.
  - `two_factor_enabled` -- boolean, default `false`.
- [ ] **Optional: recovery codes table** -- one-to-many from user, with hashed code and `used` flag.

### API Endpoints

| Method | Route | Purpose | Auth Required |
|--------|-------|---------|---------------|
| POST | `/2fa/setup` | Generate secret, return otpauth URI | Yes |
| POST | `/2fa/enable` | Validate code and activate 2FA | Yes |
| POST | `/2fa/disable` | Validate code and deactivate 2FA | Yes |
| POST | `/2fa/verify` | Validate TOTP during login | Partial (temp token) |

---

## Recommended Libraries by Platform

### .NET

| Library | Package | Notes |
|---------|---------|-------|
| **Otp.NET** | `Otp.NET` (NuGet) | Lightweight TOTP/HOTP library. Supports SHA-1/256/512, configurable digits and period. |

```csharp
// Example: Otp.NET usage
using OtpNet;

var secretBytes = KeyGeneration.GenerateRandomKey(20);
var base32Secret = Base32Encoding.ToString(secretBytes);

var totp = new Totp(secretBytes);
var code = totp.ComputeTotp();               // Generate current code
bool valid = totp.VerifyTotp(userCode, out long timeStepMatched,
    new VerificationWindow(previous: 1, future: 1));
```

### Node.js

| Library | Package | Notes |
|---------|---------|-------|
| **otpauth** | `otpauth` (npm) | Modern, well-maintained. Supports URI generation natively. |
| **speakeasy** | `speakeasy` (npm) | Mature library, widely used. Includes base32 encoding and QR URI helpers. |

```javascript
// Example: otpauth usage
import { TOTP, Secret } from 'otpauth';

const secret = new Secret({ size: 20 });
const totp = new TOTP({
  issuer: 'MyApp',
  label: 'user@example.com',
  algorithm: 'SHA1',
  digits: 6,
  period: 30,
  secret: secret,
});

const uri = totp.toString();                 // otpauth:// URI
const code = totp.generate();                // Current code
const delta = totp.validate({ token: userCode, window: 1 });
const valid = delta !== null;
```

### Python

| Library | Package | Notes |
|---------|---------|-------|
| **pyotp** | `pyotp` (pip) | Simple and widely adopted. Built-in provisioning URI generation. |

```python
# Example: pyotp usage
import pyotp

secret = pyotp.random_base32()
totp = pyotp.TOTP(secret)

uri = totp.provisioning_uri(
    name='user@example.com',
    issuer_name='MyApp'
)

code = totp.now()                            # Current code
valid = totp.verify(user_code, valid_window=1)
```

### Go

| Library | Module | Notes |
|---------|--------|-------|
| **pquerna/otp** | `github.com/pquerna/otp` | Full TOTP/HOTP support with QR code image generation built in. |

```go
// Example: pquerna/otp usage
import (
    "github.com/pquerna/otp/totp"
)

key, _ := totp.Generate(totp.GenerateOpts{
    Issuer:      "MyApp",
    AccountName: "user@example.com",
    SecretSize:  20,
})

uri := key.URL()                             // otpauth:// URI
code, _ := totp.GenerateCode(key.Secret(), time.Now())
valid := totp.Validate(userCode, key.Secret())
```

### Frontend QR Code Rendering

| Library | Package | Framework | Notes |
|---------|---------|-----------|-------|
| **qrcode.react** | `qrcode.react` (npm) | React | Renders QR codes as SVG or Canvas components. |
| **qrcode** | `qrcode` (npm) | Any | General-purpose QR generation. Supports terminal, Canvas, SVG, and data URI output. |

```jsx
// Example: qrcode.react usage
import { QRCodeSVG } from 'qrcode.react';

function TotpSetup({ otpauthUri }) {
  return (
    <div>
      <h2>Scan this QR code with your authenticator app</h2>
      <QRCodeSVG value={otpauthUri} size={256} level="M" />
    </div>
  );
}
```

---

## Architecture Diagram

```
                          SETUP FLOW
  ================================================================

  User                   Frontend                Backend                 Database
   |                        |                       |                       |
   |  1. Click "Enable 2FA" |                       |                       |
   |----------------------->|                       |                       |
   |                        |  2. POST /2fa/setup   |                       |
   |                        |---------------------->|                       |
   |                        |                       |  3. Generate secret   |
   |                        |                       |     (20 bytes,        |
   |                        |                       |      crypto-random)   |
   |                        |                       |                       |
   |                        |  4. Return otpauth:// |                       |
   |                        |     URI + base32 key  |                       |
   |                        |<----------------------|                       |
   |  5. Display QR code    |                       |                       |
   |<-----------------------|                       |                       |
   |                        |                       |                       |
   |  6. Scan QR with       |                       |                       |
   |     Authenticator App  |                       |                       |
   |     +--------------+   |                       |                       |
   |     | Auth App     |   |                       |                       |
   |     | stores secret|   |                       |                       |
   |     | shows 6-digit|   |                       |                       |
   |     | code         |   |                       |                       |
   |     +--------------+   |                       |                       |
   |                        |                       |                       |
   |  7. Enter 6-digit code |                       |                       |
   |----------------------->|                       |                       |
   |                        |  8. POST /2fa/enable  |                       |
   |                        |     { code: "482901"} |                       |
   |                        |---------------------->|                       |
   |                        |                       |  9. Validate TOTP     |
   |                        |                       |  10. Encrypt secret   |
   |                        |                       |--------------------->|
   |                        |                       |  11. Store encrypted  |
   |                        |                       |      secret + flag    |
   |                        |                       |<---------------------|
   |                        |  12. 200 OK           |                       |
   |                        |<----------------------|                       |
   |  13. "2FA Enabled!"    |                       |                       |
   |<-----------------------|                       |                       |


                          LOGIN FLOW
  ================================================================

  User                   Frontend                Backend                 Database
   |                        |                       |                       |
   |  1. Enter email +      |                       |                       |
   |     password            |                       |                       |
   |----------------------->|                       |                       |
   |                        |  2. POST /auth/login  |                       |
   |                        |     { email, password }|                      |
   |                        |---------------------->|                       |
   |                        |                       |  3. Validate password |
   |                        |                       |--------------------->|
   |                        |                       |<---------------------|
   |                        |                       |  4. Check 2FA flag   |
   |                        |                       |     (enabled = true) |
   |                        |                       |                       |
   |                        |  5. 200 OK            |                       |
   |                        |  { requiresTwoFactor:  |                       |
   |                        |    true,               |                       |
   |                        |    twoFactorToken: ... }|                      |
   |                        |<----------------------|                       |
   |  6. Show TOTP input    |                       |                       |
   |<-----------------------|                       |                       |
   |                        |                       |                       |
   |  7. Enter 6-digit code |                       |                       |
   |     from Auth App      |                       |                       |
   |----------------------->|                       |                       |
   |                        |  8. POST /2fa/verify  |                       |
   |                        |  { twoFactorToken,    |                       |
   |                        |    code: "739201" }   |                       |
   |                        |---------------------->|                       |
   |                        |                       |  9. Decrypt secret   |
   |                        |                       |--------------------->|
   |                        |                       |<---------------------|
   |                        |                       |  10. Validate TOTP   |
   |                        |                       |      (+/- 1 step)    |
   |                        |                       |                       |
   |                        |  11. 200 OK           |                       |
   |                        |  { accessToken,        |                       |
   |                        |    refreshToken }      |                       |
   |                        |<----------------------|                       |
   |  12. Authenticated!    |                       |                       |
   |<-----------------------|                       |                       |
```

---

## Known Limitations and Future Enhancements

### Version 1 Limitations

- **No recovery codes.** If the user loses access to their authenticator app, there is no self-service recovery path. An administrator must manually disable 2FA on the account.
- **No backup phone number.** There is no fallback to SMS or voice call verification.
- **Single device only.** The TOTP secret is bound to whatever authenticator app scanned the QR code. There is no built-in mechanism for syncing across devices (though some authenticator apps like Authy handle this on their own).
- **No trusted device memory.** Users must provide a TOTP code on every login.

### Future Enhancements

| Enhancement | Description | Priority |
|-------------|-------------|----------|
| **Recovery codes** | Generate 10 one-time-use backup codes during 2FA setup. Store hashed. Allow login with any unused code when the authenticator app is unavailable. | High |
| **SMS/Email fallback** | Allow users to receive a verification code via SMS or email as an alternative to their authenticator app. Requires a messaging provider integration. | Medium |
| **Hardware key support** | Implement FIDO2/WebAuthn for hardware security keys (e.g., YubiKey). This is a separate, phishing-resistant second factor. | Medium |
| **Trusted device** | After successful 2FA, offer "Remember this device for 30 days." Store a signed cookie or device fingerprint to skip 2FA on trusted devices. | Low |
| **Backup phone number** | Allow registration of a backup phone number for SMS-based recovery. | Low |
| **Admin 2FA enforcement** | Allow administrators to require 2FA for all users or specific roles. | Medium |

---

## References

- [RFC 6238 -- TOTP: Time-Based One-Time Password Algorithm](https://datatracker.ietf.org/doc/html/rfc6238)
- [RFC 4226 -- HOTP: An HMAC-Based One-Time Password Algorithm](https://datatracker.ietf.org/doc/html/rfc4226)
- [RFC 4648 -- Base Encodings (Base32)](https://datatracker.ietf.org/doc/html/rfc4648)
- [Google Authenticator Key URI Format](https://github.com/google/google-authenticator/wiki/Key-Uri-Format)
